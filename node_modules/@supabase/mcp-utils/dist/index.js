import{Server as U}from"@modelcontextprotocol/sdk/server/index.js";import{CallToolRequestSchema as b,ListResourcesRequestSchema as P,ListResourceTemplatesRequestSchema as v,ListToolsRequestSchema as E,ReadResourceRequestSchema as C}from"@modelcontextprotocol/sdk/types.js";import"zod";import O from"zod-to-json-schema";function w(e){try{return new URL(e),e}catch{throw new Error(`invalid uri: ${e}`)}}function x(e,t){let s=new URL(e),i=new URL(t);return s.href===i.href}function h(e,t){let i=new URL(e).pathname.split("/").slice(1);for(let u of t){let a=new URL(u),p=decodeURIComponent(a.pathname).split("/").slice(1);if(i.length!==p.length)continue;let o={},r=!0;for(let n=0;n<i.length;n++){let c=p[n],l=i[n];if(!c||!l)break;if(c.startsWith("{")&&c.endsWith("}")){let R=c.slice(1,-1);if(!R)break;o[R]=l}else if(i[n]!==p[n]){r=!1;break}}if(r)return{uri:u,params:o}}}function L(e,t){return{uri:e,...t}}function J(e,t){return{uriTemplate:e,...t}}function M(e,t){return{uri:e,mimeType:"application/json",...t}}function W(e,t){return{uriTemplate:e,mimeType:"application/json",...t}}function H(e,t){return t.map(s=>{if("uri"in s){let a=new URL(s.uri,`${e}://`),p=decodeURI(a.href);return{...s,uri:p}}let i=new URL(s.uriTemplate,`${e}://`),u=decodeURI(i.href);return{...s,uriTemplate:u}})}function A(e,t){return{uri:e,mimeType:"application/json",text:JSON.stringify(t)}}function V(e){return e}function Z(e){let t={};e.resources&&(t.resources={}),e.tools&&(t.tools={});let s=new U({name:e.name,version:e.version},{capabilities:t}),i,u=new Promise(o=>{i=o});async function a(){let o=await u;if(!e.resources)throw new Error("resources not available");return typeof e.resources=="function"?await e.resources(o):e.resources}async function p(){let o=await u;if(!e.tools)throw new Error("tools not available");return typeof e.tools=="function"?await e.tools(o):e.tools}return s.oninitialized=async()=>{let o=s.getClientVersion(),r=s.getClientCapabilities();if(!o)throw new Error("client info not available after initialization");if(!r)throw new Error("client capabilities not available after initialization");let n={clientInfo:o,clientCapabilities:r};await e.onInitialize?.(n),i(n)},e.resources&&(s.setRequestHandler(P,async()=>({resources:(await a()).filter(r=>"uri"in r).map(({uri:r,name:n,description:c,mimeType:l})=>({uri:r,name:n,description:c,mimeType:l}))})),s.setRequestHandler(v,async()=>({resourceTemplates:(await a()).filter(r=>"uriTemplate"in r).map(({uriTemplate:r,name:n,description:c,mimeType:l})=>({uriTemplate:r,name:n,description:c,mimeType:l}))})),s.setRequestHandler(C,async o=>{try{let r=await a(),{uri:n}=o.params,l=r.filter(m=>"uri"in m).find(m=>x(m.uri,n));if(l)return await l.read(n);let R=r.filter(m=>"uriTemplate"in m),y=R.map(({uriTemplate:m})=>w(m)),f=h(n,y);if(!f)throw new Error("resource not found");let g=R.find(m=>m.uriTemplate===f.uri);if(!g)throw new Error("resource not found");let d=await g.read(n,f.params);return{contents:Array.isArray(d)?d:[d]}}catch(r){return{isError:!0,content:[{type:"text",text:JSON.stringify({error:T(r)})}]}}})),e.tools&&(s.setRequestHandler(E,async()=>{let o=await p();return{tools:Object.entries(o).map(([r,{description:n,parameters:c}])=>({name:r,description:n,inputSchema:O(c)}))}}),s.setRequestHandler(b,async o=>{try{let r=await p(),n=o.params.name;if(!(n in r))throw new Error("tool not found");let c=r[n];if(!c)throw new Error("tool not found");let l=c.parameters.strict().parse(o.params.arguments??{}),R=await c.execute(l);return{content:R?[{type:"text",text:JSON.stringify(R)}]:[]}}catch(r){return{isError:!0,content:[{type:"text",text:JSON.stringify({error:T(r)})}]}}})),s}function T(e){if(!e||typeof e!="object")return e;let t={},s=["name","message"];for(let i of s)i in e&&(t[i]=e[i]);return t}var S=class{#e;#t;ready;readable;writable;onclose;onerror;onmessage;constructor(){let t,s,i=new Promise(a=>{t=a}),u=new Promise(a=>{s=a});this.ready=Promise.all([i,u]).then(()=>{}),this.readable=new ReadableStream({start:a=>{this.#e=a,t()}}),this.writable=new WritableStream({start:a=>{this.#t=a,s()},write:a=>{this.onmessage?.(a)}})}async start(){await this.ready}async send(t){if(!this.#e)throw new Error("readable stream not initialized");this.#e.enqueue(t)}async close(){this.#e?.error(new Error("connection closed")),this.#t?.error(new Error("connection closed")),this.onclose?.()}};export{S as StreamTransport,Z as createMcpServer,M as jsonResource,A as jsonResourceResponse,W as jsonResourceTemplate,L as resource,J as resourceTemplate,H as resources,V as tool};
//# sourceMappingURL=index.js.map